### **Метка в ассемблере**  

**Метка** — это именованный адрес в коде программы. Она указывает на место, куда можно выполнить переход (JMP, Jcc, CALL) или откуда можно начать выполнение кода.  

#### **1. Формат метки**  
```assembly
метка:
    ; Инструкции
```
📌 Метка оканчивается двоеточием (`:`) и **не является командой** — это просто адрес.  

---

## **2. Виды меток**  

### **2.1. Глобальные метки**  
Используются во всей программе (или файле).  

```assembly
start:
    mov al, 10
    jmp finish

finish:
    hlt  ; Завершение программы
```
📌 Глобальные метки уникальны в файле.  

### **2.2. Локальные метки**  
Работают внутри блока с глобальной меткой.  

```assembly
main:
    mov al, 5
.L1:    
    dec al
    jnz .L1   ; Переход к .L1, пока AL ≠ 0
```
📌 Локальная метка `.L1:` **не видна** за пределами `main:`.  

---

## **3. Метки и переходы**  

### **3.1. Безусловный переход (JMP)**  
```assembly
jmp loop_start   ; Прыжок на метку loop_start
loop_start:
    mov al, 5
```

### **3.2. Условный переход (Jcc)**  
```assembly
cmp al, 0
je zero_label  ; Если AL = 0, перейти

zero_label:
```

### **3.3. Вызов подпрограммы (CALL)**  
```assembly
call my_function
my_function:
    ret
```

---

## **4. Типы переходов в x86-64**  

Переходы различаются по дальности, то есть по способу адресации и количеству байтов в машинном коде.

### **4.1. Короткие (SHORT)**  
- Диапазон: **−128 … +127 байт** (1 байт смещения).  
- Используются для **локальных переходов в пределах одного сегмента**.  
- Оптимальны по размеру кода.  

```assembly
jmp short target_label  ; Короткий переход (до 127 байт вперёд или 128 назад)
target_label:
    nop
```
Компилируется в 2 байта: `EB XX`, где `XX` — смещение.

### **4.2. Близкие (NEAR)**  
- Диапазон: **32-битное смещение** (относительный переход).  
- Используется для **переходов внутри одного сегмента**.  
- Генерируется автоматически, если SHORT недоступен.  
- Код больше, чем у SHORT (5 байтов).  

```assembly
jmp near target_label  ; Переход в пределах одного сегмента
target_label:
    nop
```
Компилируется в `E9 XX XX XX XX`, где `XX XX XX XX` — 32-битное смещение.

### **4.3. Дальние (FAR)**  
- Диапазон: **включает сегментный адрес** (CS:IP).  
- Используется **для межсегментных переходов** (устарело в x86-64, но есть в реальном режиме).  
- Требует явного указания сегмента.  
- Код занимает **7 байтов** (2 байта сегмента + 4 байта смещения).  

```assembly
jmp far 0x1234:0x5678  ; Переход на адрес 0x1234:0x5678 (реальный режим)
```
Компилируется в `EA XX XX SS SS`, где `XX XX` — смещение, `SS SS` — сегмент.

### **4.4. Итоговая таблица**  
| Тип | Длина | Описание |
|------|--------|----------------------------------------|
| SHORT | 2 байта | Быстрый локальный переход (±127 байт) |
| NEAR | 5 байтов | Переход внутри сегмента |
| FAR | 7 байтов | Межсегментный переход (устарело) |

📌 В x86-64 **почти всегда используются NEAR переходы**.  

---

## **5. Условные переходы (JCC)**  

### **5.1. Длина переходов**  
| Тип | Размер | Дальность | Описание |
|------|--------|-----------|------------|
| SHORT | 2 байта | ±127 байт | Использует 8-битное смещение. |
| NEAR | 6 байтов | ±2 ГБ | Использует 32-битное смещение. |

📌 **JCC — это всегда либо SHORT, либо NEAR**.  
В x86-64 **нет** условных переходов FAR, потому что они используются только для JMP и CALL.

### **5.2. Виды переходов**  

#### **5.2.1. Переходы по проверке битов**  
| Инструкция | Условие |
|------------|---------|
| JC  | CF = 1 (перенос, переполнение) |
| JNC | CF = 0 (нет переноса) |
| JO  | OF = 1 (арифметическое переполнение) |
| JNO | OF = 0 (нет переполнения) |
| JS  | SF = 1 (отрицательное число) |
| JNS | SF = 0 (положительное число) |
| JP / JPE  | PF = 1 (четный битовый паритет) |
| JNP / JPO  | PF = 0 (нечетный битовый паритет) |

#### **5.2.2. Сравнение знаковых чисел**
| Инструкция  | Условие | Флаги |
|-------------|--------|------|
| JE/JZ     | A == B  | ZF=1 |
| JNE/JNZ   | A ≠ B  | ZF=0 |
| JG/JNLE   | A > B  | ZF=0, SF=OF |
| JL/JNGE   | A < B  | SF≠OF |
| JGE/JNL   | A ≥ B  | SF=OF |
| JLE/JNG   | A ≤ B  | ZF=1 или SF≠OF |

#### **5.2.3. Сравнение беззнаковых чисел**
| Инструкция | Условие  | Флаги |
|------------|---------|------|
| JA/JNBE  | A > B  | CF=0, ZF=0 |
| JB/JNAE  | A < B  | CF=1 |
| JAE/JNB  | A ≥ B  | CF=0 |
| JBE/JNA  | A ≤ B  | CF=1 или ZF=1 |

---

## **6. Вызовы и возвраты (CALL, RET)**  

### **6.1. CALL и RET**  
Для работы с подпрограммами (функциями).

- `CALL метка` → Запоминает RIP, прыгает в функцию.
- `RET` → Берёт адрес из стека, возвращает управление.

```assembly
call my_function
mov al, 1
hlt

my_function:
    mov al, 2
    ret
```
📌 CALL и RET работают со стеком.

---

## **7. Циклы (LOOP, LOOPZ, LOOPNZ)**  
Уменьшают RCX и прыгают, если RCX ≠ 0.

| Инструкция | Условие |
|------------|---------|
| LOOP     | RCX ≠ 0 |
| LOOPZ    | RCX ≠ 0 и ZF=1 |
| LOOPNZ   | RCX ≠ 0 и ZF=0 |

```assembly
mov rcx, 5
loop_start:
    dec rax
    loop loop_start   ; Пока RCX ≠ 0
```
📌 LOOP не изменяет флаги.

---

## **Вывод**  
- `JMP` — безусловный переход.  
- `Jcc` — условные переходы (используют флаги).  
- `CALL/RET` — управление подпрограммами.  
- `LOOP` — циклы на RCX.
