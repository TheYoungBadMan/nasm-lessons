### **Секции программы в памяти процесса и в ассемблере**

При выполнении программы в памяти создаётся несколько секций, каждая из которых отвечает за хранение определённых данных и инструкций. Аналогично, в ассемблере программы также делятся на секции, определяющие, где находятся код, данные и переменные.

---

### **1. Секция кода (.text)**
- Содержит исполняемый машинный код программы.
- Является **только для чтения** (read-only) для защиты от изменений.
- Обычно загружается в **низкие адреса** памяти процесса.
- Разделяется между всеми процессами, если код не изменяется во время выполнения.

**В ассемблере:**
- Объявляется с атрибутом `global _start` (для Linux).
- Включает точку входа программы.

Пример:
```assembly
section .text
    global _start

_start:
    mov rax, 60  ; syscall: exit
    xor rdi, rdi ; Код возврата 0
    syscall
```

---

### **2. Секция данных (.data, .rodata)**
#### **.data (инициализированные данные)**
- Хранит **глобальные и статические переменные**, которые **инициализированы** до запуска программы.
- Читаемо-записываемая (read-write), так как данные могут изменяться во время выполнения.

Пример в ассемблере:
```assembly
section .data
    msg db "Hello, World!", 0xA  ; Строка с переводом строки
    len equ $ - msg              ; Длина строки
```

#### **.rodata (только для чтения)**
- Содержит **константы и строковые литералы**.
- Является **только для чтения** (read-only) для защиты от модификации.

Пример в ассемблере:
```assembly
section .rodata
    pi dq 3.141592653589793
```

---

### **3. Секция BSS (.bss)**
- Хранит **неинициализированные глобальные и статические переменные**.
- При запуске программы **автоматически обнуляется** (заполняется нулями).
- Не занимает места в исполняемом файле, но резервируется в памяти.

Пример в ассемблере:
```assembly
section .bss
    buffer resb 256  ; 256 байт под буфер
```

---

### **4. Стек и куча**
#### **Стек**
- Используется для хранения **локальных переменных**, адресов возврата функций и параметров вызовов.
- Растёт **вниз** (от больших адресов к меньшим).
- Управляется автоматически с помощью инструкций `push`/`pop`.

Пример работы со стеком в ассемблере:
```assembly
push rax   ; Сохранить значение
pop rbx    ; Восстановить значение
```

#### **Куча (heap)**
- Используется для динамического выделения памяти (`malloc`, `new`).
- Растёт **вверх** (от низких адресов к высоким).
- Управляется вручную (`free`, `delete`), возможны утечки памяти.

Пример выделения памяти в куче (Linux, `mmap`):
```assembly
mov rax, 9        ; syscall: mmap
mov rdi, 0        ; addr = NULL
mov rsi, 4096     ; size = 4 KB
mov rdx, 3        ; prot = PROT_READ | PROT_WRITE
mov r10, 34       ; flags = MAP_PRIVATE | MAP_ANONYMOUS
mov r8, -1        ; fd = -1 (не используется)
mov r9, 0         ; offset = 0
syscall
```

---

### **Итоговая структура памяти процесса**
```
|   Высокие адреса   |  
|--------------------|  
|      Стек          | ← Растёт вниз  
|--------------------|  
|      ...           |  
|--------------------|  
|      Куча          | → Растёт вверх  
|--------------------|  
|   .bss (неиниц.)   |  
|--------------------|  
|   .data (иниц.)    |  
|--------------------|  
|  .rodata (конст.)  |  
|--------------------|  
|   .text (код)      |  
|--------------------|  
|   Низкие адреса    |  
```

Таким образом, программы на ассемблере и в памяти процесса имеют схожую структуру, но в ассемблере требуется явно указывать секции и управлять ресурсами вручную.

